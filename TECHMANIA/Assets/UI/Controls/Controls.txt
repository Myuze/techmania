function WaitForSeconds(seconds)
    local timer = 0
    while (timer < seconds) do
        timer = timer + time.deltaTime
        coroutine.yield()
    end
end

function SetProgressBar(progressBar, percent)
    progressBar.Q("filled-portion").style.right =
        tm.style.LengthInPercent(100 - percent)
end

function UpdateSliderAppearance(slider)
    local percent = (slider.value - slider.lowValue) * 100 / 
        (slider.highValue - slider.lowValue)
    SetProgressBar(slider.parent, percent)
    slider.Q("overlay-center").style.left =
        tm.style.LengthInPercent(percent)
end

function SetUpAllSliders(tm)
    tm.root.Query(nil, "slider").ForEach(function (element)
        element.RegisterCallback("ChangeFloat", UpdateSliderAppearance)
        element.RegisterCallback("ChangeInt", UpdateSliderAppearance)
        UpdateSliderAppearance(element)
    end)
end

function SetSliderValueWithoutNotify(slider, value)
    slider.SetValueWithoutNotify(value)
    UpdateSliderAppearance(slider)
end

function SetUpAllToggles(tm)
    tm.root.Query(nil, "toggle-track").ForEach(function (element)
        element.RegisterCallback("Click", function (track)
            track.ToggleInClassList("toggle-track-on")
            track.ToggleInClassList("toggle-track-off")
        end)
    end)
end

function IsToggleOn(trackElement)
    return trackElement.ClassListContains("toggle-track-on")
end

function SetToggleIsOn(trackElement, on)
    trackElement.EnableInClassList("toggle-track-on", on)
    trackElement.EnableInClassList("toggle-track-off", not on)
end

function SetUpClickSound(tm, className)
    tm.root.Query(nil, className).ForEach(function (element)
        local sfxName = "Assets/UI/SFX/Click.wav"
        if (element.name == "back-button" or
            element.name == "cancel-button") then
            sfxName = "Assets/UI/SFX/Back.wav"
        end
        element.RegisterCallback("Click", function ()
            tm.audio.Play(sfxName, "SFX")
        end)
    end)
end

function SetUpPointerOverSound(tm, className)
    tm.root.Query(nil, className).ForEach(function (element)
        element.RegisterCallback("PointerOver", function (element, event)
            print("event target: " .. event.target.name)
            print("element name: " .. element.name);
            -- if (event.target == element.inner) then
                tm.audio.Play("Assets/UI/SFX/Select.wav", "SFX")
            -- end
        end)
    end)
end

function SetUpButtonSounds(tm, className)
    SetUpClickSound(tm, className)
    SetUpPointerOverSound(tm, className)
end

function SetUpAllScrollingTexts(tm)
    tm.root.Query(nil, "scrolling-text-container").ForEach(function (container)
        container.Q("unity-content-and-vertical-scroll-container").pickable = false
        container.Q("unity-content-viewport").pickable = false
        container.Q("unity-content-container").pickable = false
        container.RegisterCallback("FrameUpdate", function(element)
            local low = element.horizontalScroller.lowValue
            local high = element.horizontalScroller.highValue
            if (float.IsNaN(high) or high <= low) then
                return
            end
            local scrollDuration = 4
            local pingPongTime = math.PingPong(time.time, scrollDuration)
            -- InverseLerp's output is clamped between 0 and 1.
            local value = math.InverseLerp(scrollDuration * 0.25, scrollDuration * 0.75, pingPongTime)
            element.horizontalScroller.value = math.Lerp(low, high, value)
        end)
    end)
end

function InitializeControls(tm)
    -- To apply themes to dropdowns
    tm.SetThemeStyleSheet("Assets/UI/Theme StyleSheet.tss")
    SetUpAllSliders(tm)
    SetUpAllToggles(tm)
    SetUpButtonSounds(tm, "button-text")
    SetUpButtonSounds(tm, "button-outlined")
    SetUpButtonSounds(tm, "button-contained")
    SetUpButtonSounds(tm, "button-card")
    SetUpButtonSounds(tm, "toggle-track")
    SetUpButtonSounds(tm, "input-field")
    SetUpPointerOverSound(tm, "slider")
    SetUpAllScrollingTexts(tm)
end

function TransitionPanelCoroutine(from, to, direction)
    local transitionTime = 0.2
    local transitionLength = 100 * direction
    function DampedLerp(a, b, t)
        return math.Lerp(a, b, math.Pow(t, 0.6))
    end

    local timer = 0
    from.display = true
    from.style.opacity = tm.style.Float(1)
    while (timer < transitionTime) do
        local progress = timer / transitionTime
        local x = DampedLerp(0, transitionLength, progress)
        from.style.opacity = tm.style.Float(1 - progress)
        from.style.translate = tm.style.TranslateInPixel(x, 0)
        timer = timer + time.deltaTime
        coroutine.yield()
    end
    from.display = false

    timer = 0
    to.style.opacity = tm.style.Float(0)
    to.display = true
    while (timer < transitionTime) do
        local progress = timer / transitionTime
        local x = DampedLerp(-transitionLength, 0, progress)
        to.style.opacity = tm.style.Float(progress)
        to.style.translate = tm.style.TranslateInPixel(x, 0)
        timer = timer + time.deltaTime
        coroutine.yield()
    end
end

function TransitionPanelFromLeft(from, to)
    tm.StartCoroutine(function()
        TransitionPanelCoroutine(from, to, 1)
    end)
end

function TransitionPanelFromRight(from, to)
    tm.StartCoroutine(function()
        TransitionPanelCoroutine(from, to, -1)
    end)
end