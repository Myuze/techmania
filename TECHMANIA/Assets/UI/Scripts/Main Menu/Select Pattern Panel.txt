selectedTrackFolder = ""
selectedFullTrack = nil
allPatternRadioButtons = {}
previewPlaybackCoroutine = nil
previewTrackAudioSource = nil
radarOfSelectedPattern = nil

-- pattern may be nil.
function ShowPatternDetails(tm, panel, pattern)
    if (pattern == nil) then
        panel.Q("bpm").Q("content").text = ""
        panel.Q("length").Q("content").text = ""
        panel.Q("notes").Q("content").text = ""
        panel.Q("author").Q("content").text = ""
        panel.Q("record").Q("content").text = ""
        panel.Q("record").Q("medal-text").text = ""
        return
    end

    -- This also enables radar calculation.
    pattern.PrepareForTimeCalculation()

    -- BPM range
    local minBpm = pattern.patternMetadata.initBpm
    local maxBpm = minBpm
    for _, e in ipairs(pattern.bpmEvents) do
        if (e.bpm < minBpm) then minBpm = e.bpm end
        if (e.bpm > maxBpm) then maxBpm = e.bpm end
    end
    function FormatBpm(bpm)
        local rounded = mathf.RoundToInt(bpm)
        if (mathf.Abs(rounded - bpm) < mathf.Epsilon) then
            return tostring(rounded)
        else
            return netString.Format("{0:F2}", bpm)
        end
    end
    if (minBpm < maxBpm) then
        panel.Q("bpm").Q("content").text = FormatBpm(minBpm) .. " - " .. FormatBpm(maxBpm)
    else
        panel.Q("bpm").Q("content").text = FormatBpm(minBpm)
    end
    SetUpScrollingText(tm, panel.Q("bpm").Q("container"))

    -- Length
    local length = 0
    -- This function returns void and has 2 out parameters
    _, length, _ = pattern.GetLengthInSecondsAndScans()
    local minutes = mathf.FloorToInt(length / 60)
    local seconds = mathf.FloorToInt(length - minutes * 60)
    if (seconds < 10) then 
        panel.Q("length").Q("content").text = minutes .. ":0" .. seconds
    else
        panel.Q("length").Q("content").text = minutes .. ":" .. seconds
    end

    -- Note count
    local noteCount = 0
    local notes = pattern.NotesAsList()
    for _, note in ipairs(notes) do
        if (note.lane < pattern.patternMetadata.playableLanes) then
            noteCount = noteCount + 1
        end
    end
    panel.Q("notes").Q("content").text = noteCount

    -- Author
    panel.Q("author").Q("content").text = pattern.patternMetadata.author

    -- Record
    local record = tm.records.GetRecord(pattern)
    if (record == nil) then
        panel.Q("record").Q("content").text = "---"
        panel.Q("record").Q("medal-text").text = ""
    else
        local score = record.GetScore()
        panel.Q("record").Q("content").text = score .. "   " .. ScoreToRank(score)
        local medal = record.GetMedal()
        if (medal == "NoMedal") then
            panel.Q("record").Q("medal-text").text = ""
        elseif (medal == "AllCombo") then
            panel.Q("record").Q("medal-text").text = tm.l10n.GetString("full_combo_medal")
        elseif (medal == "PerfectPlay") then
            panel.Q("record").Q("medal-text").text = tm.l10n.GetString("perfect_play_medal")
        elseif (medal == "AbsolutePerfect") then
            panel.Q("record").Q("medal-text").text = tm.l10n.GetString("absolute_perfect_medal")
        end
    end

    -- Radar
    radarOfSelectedPattern = CalculateRadarOfPattern(pattern)
    panel.Q("radar").MarkDirtyRepaint()
end

function ShowSelectPatternPanel(tm)
    local panel = tm.root.Q("select-pattern-panel")
    local track = selectedFullTrack
    StartPreviewTrackPlayback(tm, selectedTrackFolder, track.trackMetadata)

    local eyecatchPath = tm.paths.Combine(selectedTrackFolder, track.trackMetadata.eyecatchImage)
    LoadAndShowEyecatch(tm, eyecatchPath, panel.Q("eyecatch"))
    panel.Q("metadata-wrap").Q("genre").text = tm.paths.EscapeBackslash(track.trackMetadata.genre)
    panel.Q("metadata-wrap").Q("title").text = tm.paths.EscapeBackslash(track.trackMetadata.title)
    panel.Q("metadata-wrap").Q("artist").text = tm.paths.EscapeBackslash(track.trackMetadata.artist)

    panel.Q("pattern-list").Q("no-pattern-text").display = (#track.patterns == 0)
    local patternListContainer = panel.Q("pattern-list").Q("unity-content-container")
    for _, child in ipairs(patternListContainer.Children()) do
        child.RemoveFromHierarchy()
    end
    allPatternRadioButtons = {}
    for _, pattern in ipairs(track.patterns) do
        local radioButton = patternListContainer.InstantiateTemplate("Assets/UI/Templates/Pattern Radio Button.uxml").Q("radio-button")
        table.insert(allPatternRadioButtons, radioButton)
        SetUpButtonSounds(tm, radioButton)

        local metadata = pattern.patternMetadata

        radioButton.Q("2l-icon").display = metadata.playableLanes == 2
        radioButton.Q("3l-icon").display = metadata.playableLanes == 3
        radioButton.Q("4l-icon").display = metadata.playableLanes == 4
        radioButton.Q("touch-icon").display = metadata.controlSchemeString == "Touch"
        radioButton.Q("keys-icon").display = metadata.controlSchemeString == "Keys"
        radioButton.Q("km-icon").display = metadata.controlSchemeString == "KM"
        radioButton.Q("level").text = metadata.level
        radioButton.Q("pattern-name").text = metadata.patternName
        SetUpScrollingText(tm, radioButton.Q("pattern-name-container"))

        local record = tm.records.GetRecord(pattern)
        local medal = ""
        if (record != nil) then
            medal = record.GetMedal()
        end
        if (medal == "AbsolutePerfect" or
            medal == "PerfectPlay") then
            radioButton.Q("perfect-play-icon").display = true
            radioButton.Q("all-combo-icon").display = false
        elseif (medal == "AllCombo") then
            radioButton.Q("perfect-play-icon").display = false
            radioButton.Q("all-combo-icon").display = true
        else
            radioButton.Q("perfect-play-icon").display = false
            radioButton.Q("all-combo-icon").display = false
        end

        radioButton.RegisterCallback("Click", function(_, _, pattern)
            SetRadioButton(radioButton, allPatternRadioButtons)
            ShowPatternDetails(tm, panel, pattern)
            panel.Q("play-button").SetEnabled(true)
        end, pattern)
    end
    SetRadioButton(nil, allPatternRadioButtons)
    ShowPatternDetails(tm, panel, nil)
    panel.Q("play-button").SetEnabled(false)
end

function InitializeSelectPatternPanel(tm)
    local panel = tm.root.Q("select-pattern-panel")

    panel.Q("radar").SetMeshPainterFunction(function(element, painter)
        painter.SetLineWidth(2)
        painter.SetLineCap("Round")
        painter.SetLineJoin("Miter")

        local majorStrokeAlpha = 0.12
        local minorStrokeAlpha = 0.05

        local centerX = element.contentRect.width * 0.5
        local centerY = element.contentRect.height * 0.5
        local radiusUnit = 13 / 20

        function AngleForVertex(i)
            return (-90 + 72 * i) * mathf.Deg2Rad
        end

        -- Draw radii, lines from the center to vertices of the outmost pentagon
        painter.SetStrokeColor(1, 1, 1, majorStrokeAlpha)
        for i = 1, 5 do
            local angle = AngleForVertex(i)
            painter.BeginPath()
            painter.MoveTo(centerX, centerY)
            painter.LineTo(
                centerX + radiusUnit * 100 * mathf.Cos(angle),
                centerY + radiusUnit * 100 * mathf.Sin(angle))
            painter.ClosePath()
            painter.Stroke()
        end

        -- Draw pentagons
        for pentagon = 1, 5 do
            local radius = radiusUnit * pentagon * 20
            if (pentagon == 5) then
                painter.SetStrokeColor(1, 1, 1, majorStrokeAlpha)
            else
                painter.SetStrokeColor(1, 1, 1, minorStrokeAlpha)
            end
            painter.BeginPath()
            painter.MoveTo(centerX, centerY - radius)
            for vertex = 1, 4 do
                local angle = AngleForVertex(vertex)
                painter.LineTo(
                    centerX + radius * mathf.Cos(angle),
                    centerY + radius * mathf.Sin(angle))
            end
            painter.ClosePath()
            painter.Stroke()
        end

        -- Draw radar
        if (radarOfSelectedPattern ~= nil) then
            painter.SetFillColor(165 / 256, 214 / 256, 167 / 256)
            painter.BeginPath()
            painter.MoveTo(centerX, centerY - radiusUnit * radarOfSelectedPattern.density)
            function DrawRadarDimension(vertex, normalized)
                local angle = AngleForVertex(vertex)
                painter.LineTo(
                    centerX + radiusUnit * normalized * mathf.Cos(angle),
                    centerY + radiusUnit * normalized * mathf.Sin(angle))
            end
            DrawRadarDimension(1, radarOfSelectedPattern.peak)
            DrawRadarDimension(2, radarOfSelectedPattern.speed)
            DrawRadarDimension(3, radarOfSelectedPattern.chaos)
            DrawRadarDimension(4, radarOfSelectedPattern.async)
            painter.ClosePath()
            painter.Fill()
        end
    end)
end

function StartPreviewTrackPlayback(tm, trackFolder, trackMetadata)
    if (previewPlaybackCoroutine != nil) then
        tm.StopCoroutine(previewPlaybackCoroutine)
    end

    if (trackMetadata.previewTrack == nil) then return end
    if (trackMetadata.previewTrack == "") then return end
    if (trackMetadata.previewStartTime > trackMetadata.previewEndTime) then return end
    local previewPath = tm.paths.Combine(trackFolder, trackMetadata.previewTrack)

    tm.io.LoadAudio(previewPath, function(status, clip)
        if (not status.Ok()) then return end
        -- TODO: what if the user transitioned away while loading the clip?
        local startTime = trackMetadata.previewStartTime
        local endTime = trackMetadata.previewEndTime
        if (startTime < 0) then startTime = 0 end
        if (endTime > clip.length) then endTime = clip.length end
        if (endTime == 0) then endTime = clip.length end
        local previewLength = endTime - startTime
        local fadeLength = 1
        if (fadeLength > previewLength * 0.5) then fadeLength = previewLength * 0.5 end

        previewPlaybackCoroutine = tm.StartCoroutine(function()
            while (true) do
                local timer = 0
                -- Start at volume 0
                previewTrackAudioSource = tm.audio.PlayClip(clip, "Music", startTime, 0)
                while (timer < fadeLength) do
                    previewTrackAudioSource.volume = timer / fadeLength
                    timer = timer + time.deltaTime
                    coroutine.yield()
                end
                previewTrackAudioSource.volume = 1
                timer = 0
                while (timer < previewLength - fadeLength * 2) do
                    timer = timer + time.deltaTime
                    coroutine.yield()
                end
                timer = 0
                while (timer < fadeLength) do
                    previewTrackAudioSource.volume = 1 - timer / fadeLength
                    timer = timer + time.deltaTime
                    coroutine.yield()
                end
            end
        end)
    end)
end

-- Called when transitioning back to select track panel, or to the game.
function StopPreviewTrackPlayback(tm)
    if (previewPlaybackCoroutine != nil) then
        tm.StopCoroutine(previewPlaybackCoroutine)
        previewPlaybackCoroutine = nil
    end
    
    if (previewTrackAudioSource != nil and previewTrackAudioSource.isPlaying) then
        tm.StartCoroutine(function()
            local timer = 0
            local fadeLength = 0.2
            while (timer < fadeLength) do
                previewTrackAudioSource.volume = 1 - timer / fadeLength
                timer = timer + time.deltaTime
                coroutine.yield()
            end
            previewTrackAudioSource.Stop()
        end)
    end
end

InitializeSelectPatternPanel(tm)