function KeyFromValue(table, value)
    for k, v in pairs(table) do
        if (v == value) then
            return k
        end
    end
    return nil
end

function LoadAndShowEyecatch(path, eyecatchElement)
    util.io.LoadTextureFromFile(path, function(status, texture)
        if (status.Ok()) then
            eyecatchElement.backgroundImage = texture
            eyecatchElement.Q("default-eyecatch").visible = false
        else
            eyecatchElement.Q("default-eyecatch").visible = true
        end
    end)
end

function ScoreToRank(score)
    if (score > 295000) then
        return "S++"
    elseif (score > 290000) then
        return "S+"
    elseif (score > 285000) then
        return "S"
    elseif (score > 280000) then
        return "A++"
    elseif (score > 270000) then
        return "A+"
    elseif (score > 260000) then
        return "A"
    elseif (score > 220000) then
        return "B"
    else
        return "C"
    end
end

-- Returns a table with keys "density", "peak", "speed", "chaos" and "async".
-- Make sure to call pattern.PrepareForTimeCalculation() before this.
function CalculateRadarOfPattern(pattern)
    local radar = {}
    if (pattern == nil) then
        radar.density = 0
        radar.peak = 0
        radar.speed = 0
        radar.chaos = 0
        radar.async = 0
        return radar
    end

    -- Pre-processing
    local seconds = 0
    local scans = 0
    _, seconds, scans = pattern.GetLengthInSecondsAndScans()
    local pulsesPerBeat = 240
    local pulsesPerScan = pattern.patternMetadata.bps * pulsesPerBeat
    local playableNotes = 0
    local notesInScan = {}
    local numChaosNotes = 0
    local numAsyncNotes = 0
    local allNotes = pattern.notesAsList()
    for _, n in ipairs(allNotes) do
        if (n.lane < pattern.patternMetadata.playableLanes) then
            playableNotes = playableNotes + 1

            local scan = math.floor(n.pulse / pulsesPerScan)
            if (notesInScan[scan] == nil) then notesInScan[scan] = 0 end
            notesInScan[scan] = notesInScan[scan] + 1

            if (n.pulse % (pulsesPerBeat / 2) ~= 0) then
                numChaosNotes = numChaosNotes + 1
            end

            if (n.type == tm.enum.noteType.Hold or
                n.type == tm.enum.noteType.RepeatHeadHold) then
                numAsyncNotes = numAsyncNotes + 0.5
            elseif (n.type == tm.enum.noteType.Repeat or
                n.type == tm.enum.noteType.RepeatHold) then
                numAsyncNotes = numAsyncNotes + 1
            end
        end
    end
    
    function Normalize(raw, min, max)
        local t = unity.mathf.InverseLerp(min, max, raw)
        return unity.mathf.RoundToInt(t * 100)
    end

    -- Density: average number of notes per second.
    local density = 0
    if (seconds > 0) then
        density = playableNotes / seconds
    end
    radar.density = Normalize(density, 0.5, 8)

    -- Peak: peak number of notes per second.
    local peak = 0
    for scan, notes in pairs(notesInScan) do  -- Not ipairs here as some scans may be empty
        local startTime = pattern.PulseToTime(scan * pulsesPerScan)
        local endTime = pattern.PulseToTime((scan + 1) * pulsesPerScan)
        local densityOfThisScan = notes / (endTime - startTime)
        if (densityOfThisScan > peak) then peak = densityOfThisScan end
    end
    radar.peak = Normalize(peak, 1, 18)

    -- Speed: average scans per minute.
    local speed = 0
    if (seconds > 0) then
        speed = scans * 60 / seconds
    end
    radar.speed = Normalize(speed, 12, 55)

    -- Chaos: percentage of notes that are not 4th or 8th notes.
    local chaos = 0
    if (playableNotes > 0) then
        chaos = numChaosNotes * 100 / playableNotes
    end
    radar.chaos = Normalize(chaos, 0, 50)

    -- Async: percentage of notes that are hold or repeat notes.
    local async = 0
    if (playableNotes > 0) then
        async = numAsyncNotes * 100 / playableNotes
    end
    radar.async = Normalize(async, 0, 40)

    return radar
end

function InitializeVolumeSliders(container)
    function InitializeOneVolumeSlider(wrapName, optionKey)
        local wrap = container.Q(wrapName)
        local slider = wrap.Q("slider")
        local valueDisplay = wrap.Q("value-display")

        slider.lowValue = 0
        slider.highValue = 100
        slider.RegisterCallback(eventType.ChangeInt, function(element, event)
            tm.options[optionKey] = event.newValue
            tm.options.ApplyVolumeSettings()
            valueDisplay.text = tostring(event.newValue)
        end)
    end
    InitializeOneVolumeSlider("master", "masterVolumePercent")
    InitializeOneVolumeSlider("music", "musicVolumePercent")
    InitializeOneVolumeSlider("keysounds", "keysoundVolumePercent")
    InitializeOneVolumeSlider("sound-effects", "sfxVolumePercent")
end

function ShowVolumeSliders(container)
    function ShowOneVolumeSlider(wrapName, optionKey)
        local wrap = container.Q(wrapName)
        local slider = wrap.Q("slider")
        local valueDisplay = wrap.Q("value-display")

        SetSliderValueWithoutNotify(slider, tm.options[optionKey])
        valueDisplay.text = tostring(tm.options[optionKey])
    end
    ShowOneVolumeSlider("master", "masterVolumePercent")
    ShowOneVolumeSlider("music", "musicVolumePercent")
    ShowOneVolumeSlider("keysounds", "keysoundVolumePercent")
    ShowOneVolumeSlider("sound-effects", "sfxVolumePercent")
end

-- Uses the selectedTrackOptions global variable.
function InitializeBgBrightnessSlider(container)
    local slider = container.Q("slider")
    slider.lowValue = 0
    slider.highValue = 10
    slider.RegisterCallback(eventType.ChangeInt, function(element, event)
        if (selectedTrackOptions == nil) then return end
        selectedTrackOptions.backgroundBrightness = event.newValue
        container.Q("value-display").text = tostring(event.newValue)
        if (tm.game.state == tm.enum.gameState.Ongoing or tm.game.state == tm.enum.gameState.Paused) then
            tm.game.UpdateBgBrightness()
        end
    end)
end

-- Uses the selectedTrackOptions global variable.
function ShowBgBrightnessSlider(container)
    SetSliderValueWithoutNotify(container.Q("slider"), selectedTrackOptions.backgroundBrightness)
    container.Q("value-display").text = tostring(selectedTrackOptions.backgroundBrightness)
end