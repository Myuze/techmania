function KeyFromValue(table, value)
    for k, v in pairs(table) do
        if (v == value) then
            return k
        end
    end
    return nil
end

function LoadAndShowEyecatch(tm, path, eyecatchElement)
    tm.io.LoadTexture(path, function(status, texture)
        if (status.Ok()) then
            eyecatchElement.backgroundImage = texture
            eyecatchElement.Q("default-eyecatch").visible = false
        else
            eyecatchElement.Q("default-eyecatch").visible = true
        end
    end)
end

function ScoreToRank(score)
    if (score > 295000) then
        return "S++"
    elseif (score > 290000) then
        return "S+"
    elseif (score > 285000) then
        return "S"
    elseif (score > 280000) then
        return "A++"
    elseif (score > 270000) then
        return "A+"
    elseif (score > 260000) then
        return "A"
    elseif (score > 220000) then
        return "B"
    else
        return "C"
    end
end

-- Returns a table with keys "density", "peak", "speed", "chaos" and "async".
-- Make sure to call pattern.PrepareForTimeCalculation() before this.
function CalculateRadarOfPattern(pattern)
    -- Pre-processing
    local seconds = 0
    local scans = 0
    _, seconds, scans = pattern.GetLengthInSecondsAndScans()
    local pulsesPerBeat = 240
    local pulsesPerScan = pattern.patternMetadata.bps * pulsesPerBeat
    local playableNotes = 0
    local notesInScan = {}
    local numChaosNotes = 0
    local numAsyncNotes = 0
    local allNotes = pattern.notesAsList()
    for _, n in ipairs(allNotes) do
        if (n.lane < pattern.patternMetadata.playableLanes) then
            playableNotes = playableNotes + 1

            local scan = math.floor(n.pulse / pulsesPerScan)
            if (notesInScan[scan] == nil) then notesInScan[scan] = 0 end
            notesInScan[scan] = notesInScan[scan] + 1

            if (n.pulse % (pulsesPerBeat / 2) ~= 0) then
                numChaosNotes = numChaosNotes + 1
            end

            if (n.typeString == "Hold" or
                n.typeString == "RepeatHeadHold") then
                numAsyncNotes = numAsyncNotes + 0.5
            elseif (n.typeString == "Repeat" or
                n.typeString == "RepeatHold") then
                numAsyncNotes = numAsyncNotes + 1
            end
        end
    end

    local radar = {}
    function Normalize(raw, min, max)
        local t = mathf.InverseLerp(min, max, raw)
        return mathf.RoundToInt(t * 100)
    end

    -- Density: average number of notes per second.
    local density = 0
    if (seconds > 0) then
        density = playableNotes / seconds
    end
    radar.density = Normalize(density, 0.5, 8)

    -- Peak: peak number of notes per second.
    local peak = 0
    for scan, notes in pairs(notesInScan) do  -- Not ipairs here as some scans may be empty
        local startTime = pattern.PulseToTime(scan * pulsesPerScan)
        local endTime = pattern.PulseToTime((scan + 1) * pulsesPerScan)
        local densityOfThisScan = notes / (endTime - startTime)
        if (densityOfThisScan > peak) then peak = densityOfThisScan end
    end
    radar.peak = Normalize(peak, 1, 18)

    -- Speed: average scans per minute.
    local speed = 0
    if (seconds > 0) then
        speed = scans * 60 / seconds
    end
    radar.speed = Normalize(speed, 12, 55)

    -- Chaos: percentage of notes that are not 4th or 8th notes.
    local chaos = 0
    if (playableNotes > 0) then
        chaos = numChaosNotes * 100 / playableNotes
    end
    radar.chaos = Normalize(chaos, 0, 50)

    -- Async: percentage of notes that are hold or repeat notes.
    local async = 0
    if (playableNotes > 0) then
        async = numAsyncNotes * 100 / playableNotes
    end
    radar.async = Normalize(async, 0, 40)

    return radar
end